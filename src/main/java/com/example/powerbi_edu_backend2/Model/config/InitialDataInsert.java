package com.example.powerbi_edu_backend2.Model.config;

import com.example.powerbi_edu_backend2.Model.Entities.*;
import com.example.powerbi_edu_backend2.Repository.*;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.time.LocalDateTime;
import java.util.List;


@Component
public class InitialDataInsert {

    private final DAXFunctionsRepository daxFunctionsRepository;

    public InitialDataInsert(DAXFunctionsRepository daxFunctionsRepository) {
        this.daxFunctionsRepository = daxFunctionsRepository;
    }



    @PostConstruct
    public void initData()
    {

        this.daxFunctionsRepository.save(new DAXFunctions("CALENDAR(<start_date>, <end_date>)", List.of("start_date: Any DAX expression that returns a datetime value.", "end_date: Any DAX expression that returns a datetime value."), "Returns a table with a single column named \"Date\" containing a contiguous set of dates.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("CALENDARAUTO([fiscal_year_end_month])", List.of("fiscal_year_end_month: Any DAX expression that returns an integer from 1 to 12. If omitted, defaults to the value specified in the calendar table template for the current user, if present; otherwise, defaults to 12."), "Returns a table with a single column named \"Date\" that contains a contiguous set of dates.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("DATE(<year>, <month>, <day>)", List.of("year: A number representing the year.", "month: A number representing the month or a calculation", "day: A number representing the day or a calculation"), "Returns the specified date (datetime).", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("DATEDIFF(<Date1>, <Date2>, <Interval>)", List.of("Date1: A scalar datetime value.", "Date2: A scalar datetime value.", "Interval: The interval to use when comparing dates."), "The count of interval boundaries between two dates.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("DATEVALUE(date_text)", List.of("date_text: Text that represents a date."), "A date in datetime format.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("DAY(<date>)", List.of("date: A date in datetime format, or a text representation of a date."), "An integer number indicating the day of the month.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("EDATE(<start_date>, <months>)", List.of("start_date: A date in datetime or text format that represents the start date.", "months: An integer that represents the number of months before or after start_date."), "A date (datetime).", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("EOMONTH(<start_date>, <months>)", List.of("start_date: The start date in datetime format, or in an accepted text representation of a date.", "months: A number representing the number of months before or after the start_date."), "A date (datetime).", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("HOUR(<datetime>)", List.of("datetime: A datetime value, such as 16:48:00 or 4:48 PM."), "An integer number from 0 to 23.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("MINUTE(<datetime>)", List.of("datetime: A datetime value or text in an accepted time format, such as 16:48:00 or 4:48 PM."), "An integer number from 0 to 59.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("NETWORKDAYS(<start_date>, <end_date>[, <weekend>, <holidays>])", List.of("start_date: A date that represents the start date. ", "end_date: A date that represents the end date.", "weekend: Indicates the days of the week that are weekend days and are not included in the number of whole working days between start_date and end_date.", "holidays: A column table of one or more dates that are to be excluded from the working day calendar."), "An integer number of whole workdays.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("QUARTER(<date>)", List.of("date: A date."), "An integer number from 1 to 4.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("WEEKDAY(<date>, <return_type>)", List.of("date: A date in datetime format.", "return_type: A number that determines the Return value"), "An integer number from 1 to 7.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("WEEKNUM(<date>[, <return_type>])", List.of("date: A date.", "return_type: (Optional) A number that determines on which day the week begins. Default is 1. See Remarks."), "An integer number.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));
        this.daxFunctionsRepository.save(new DAXFunctions("YEAR(<date>)", List.of("date: A date in datetime or text format, containing the year you want to find."), "An integer in the range 1900-9999.", "Date and time functions", "These functions help you create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions. However, DAX functions use a datetime data type, and can take values from a column as an argument."));

        this.daxFunctionsRepository.save(new DAXFunctions("APPROXIMATEDISTINCTCOUNT(<columnName>)", List.of("column: The column that contains the values to be counted. This cannot be an expression."), "The approximate number of distinct values in column.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("AVERAGE(<column>)", List.of("column: The column that contains the numbers for which you want the average."), "Returns a decimal number that represents the arithmetic mean of the numbers in the column.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("AVERAGEA(<column>)", List.of("column: A column that contains the values for which you want the average."), "A decimal number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("AVERAGEX(<table>,<expression>)", List.of("table: Name of a table, or an expression that specifies the table over which the aggregation can be performed.", "expression: An expression with a scalar result, which will be evaluated for each row of the table in the first argument."), "A decimal number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("COUNT(<column>)", List.of("column: The column that contains the values to be counted."), "A whole number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("COUNTAX(<table>,<expression>)", List.of("table: The table containing the rows for which the expression will be evaluated.", "expression: The expression to be evaluated for each row of the table."), "A whole number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("COUNTBLANK(<column>)", List.of("column: The column that contains the blank cells to be counted."), "A whole number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("DISTINCTCOUNT(<column>)", List.of("column: The column that contains the values to be counted"), "The number of distinct values in column.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("DISTINCTCOUNTNOBLANK (<column>)", List.of("column: The column that contains the values to be counted"), "The number of distinct values in column.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("MAXA(<column>)", List.of("column: The column in which you want to find the largest value."), "The largest value.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("MINA(<column>)", List.of("column: The column for which you want to find the minimum value."), "The smallest value.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("PRODUCT(<column>)", List.of("column: The column that contains the numbers for which the product is to be computed."), "A decimal number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));
        this.daxFunctionsRepository.save(new DAXFunctions("SUM(<column>)", List.of("column: The column that contains the numbers to sum."), "A decimal number.", "Aggregation functions", "Aggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression."));


        this.daxFunctionsRepository.save(new DAXFunctions("ALL( [<table> | <column>[, <column>[, <column>[,…]]]] )", List.of("table: The table that you want to clear filters on.", "column: The column that you want to clear filters on."), "The table or column with filters removed.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("ALLEXCEPT(<table>,<column>[,<column>[,…]])", List.of("table: The table over which all context filters are removed, except filters on those columns that are specified in subsequent arguments.", "column: The column for which context filters must be preserved."), "The first argument to the ALLEXCEPT function must be a reference to a base table.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("ALLSELECTED([<tableName> | <columnName>[, <columnName>[, <columnName>[,…]]]] )", List.of("tableName: The name of an existing table, using standard DAX syntax. This parameter cannot be an expression. This parameter is optional.", "columnName: The name of an existing column using standard DAX syntax, usually fully qualified. It cannot be an expression. This parameter is optional."), "The context of the query without any column and row filters.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("CALCULATE(<expression>[, <filter1> [, <filter2> [, …]]])", List.of("expression: The expression to be evaluated.", "filter1, filter2,…: (Optional) Boolean expressions or table expressions that defines filters, or filter modifier functions."), "The value that is the result of the expression.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("CALCULATETABLE(<expression>[, <filter1> [, <filter2> [, …]]])", List.of("expression: The table expression to be evaluated.", "filter1, filter2,…: (Optional) Boolean expressions or table expressions that defines filters, or filter modifier functions."), "A table of values.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("EARLIER(<column>, <number>)", List.of("column: A column or expression that resolves to a column.", "num: (Optional) A positive number to the outer evaluation pass."), "The current value of row, from column, at number of outer evaluation passes.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("EARLIEST(<column>)", List.of("column: A reference to a column."), "A column with filters removed.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("FILTER(<table>,<filter>)", List.of("table: The table to be filtered. The table can also be an expression that results in a table.", "filter: A Boolean expression that is to be evaluated for each row of the table. For example, [Amount] > 0 or [Region] = \"France\""), "A table containing only the filtered rows.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("KEEPFILTERS(<expression>)", List.of("expression: Any expression."), "A table of values.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("REMOVEFILTERS([<table> | <column>[, <column>[, <column>[,…]]]])", List.of("table: The table that you want to clear filters on.", "column: The column that you want to clear filters on."), "N/A. See remarks.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));
        this.daxFunctionsRepository.save(new DAXFunctions("SELECTEDVALUE(<columnName>[, <alternateResult>])", List.of("columnName: The name of an existing column, using standard DAX syntax. It cannot be an expression.", "alternateResult: (Optional) The value returned when the context for columnName has been filtered down to zero or more than one distinct value. When not provided, the default value is BLANK()."), "The value when the context for columnName has been filtered down to one distinct value only.", "Filter functions", "The filter and value functions in DAX are some of the most complex and powerful, and differ greatly from Excel functions. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations."));


        this.daxFunctionsRepository.save(new DAXFunctions("CONTAINS(<table>, <columnName>, <value>[, <columnName>, <value>]…)", List.of("table: Any DAX expression that returns a table of data.", "columnName: The name of an existing column, using standard DAX syntax. It cannot be an expression.", "value: Any DAX expression that returns a single scalar value, that is to be sought in columnName. "), "A value of TRUE if each specified value can be found in the corresponding columnName, or are contained, in those columns; otherwise, the function returns FALSE.", "Information functions", "DAX information functions look at the cell or row that is provided as an argument and tells you whether the value matches the expected type. For example, the ISERROR function returns TRUE if the value that you reference contains an error."));
        this.daxFunctionsRepository.save(new DAXFunctions("ISBLANK(<value>)", List.of("value: The value or expression you want to test."), "A Boolean value of TRUE if the value is blank; otherwise FALSE.", "Information functions", "DAX information functions look at the cell or row that is provided as an argument and tells you whether the value matches the expected type. For example, the ISERROR function returns TRUE if the value that you reference contains an error."));



        this.daxFunctionsRepository.save(new DAXFunctions("AND(<logical1>,<logical2>)", List.of("logical_1, logical_2: The logical values you want to test."), "Returns true or false depending on the combination of values that you test.", "Logical functions", "Logical functions act upon an expression to return information about the values or sets in the expression. For example, you can use the IF function to check the result of an expression and create conditional results."));
        this.daxFunctionsRepository.save(new DAXFunctions("COALESCE(<expression>, <expression>[, <expression>]…)", List.of("expression: Any DAX expression that returns a scalar expression."), "A scalar value coming from one of the expressions or BLANK if all expressions evaluate to BLANK.", "Logical functions", "Logical functions act upon an expression to return information about the values or sets in the expression. For example, you can use the IF function to check the result of an expression and create conditional results."));


        this.daxFunctionsRepository.save(new DAXFunctions("ABS(<number>)", List.of("number: The number for which you want the absolute value."), "A decimal number.", "Math and Trig functions", "The mathematical functions in Data Analysis Expressions (DAX) are very similar to the Excel mathematical and trigonometric functions. This section lists the mathematical functions provided by DAX."));
        this.daxFunctionsRepository.save(new DAXFunctions("FACT(<number>)", List.of("number: The non-negative number for which you want to calculate the factorial."), "A decimal number.", "Math and Trig functions", "The mathematical functions in Data Analysis Expressions (DAX) are very similar to the Excel mathematical and trigonometric functions. This section lists the mathematical functions provided by DAX."));


        this.daxFunctionsRepository.save(new DAXFunctions("COMBINEVALUES(<delimiter>, <expression>, <expression>[, <expression>]…)", List.of("delimiter: A separator to use during concatenation. Must be a constant value.", "expression: A DAX expression whose value will be be joined into a single text string."), "A concatenated string.", "Text functions", "Data Analysis Expressions (DAX) includes a set of text functions based on the library of string functions in Excel, but which have been modified to work with tables and columns in tabular models. This section describes text functions available in the DAX language."));
        this.daxFunctionsRepository.save(new DAXFunctions("FORMAT(<value>, <format_string>[, <locale_name>])", List.of("value: A value or expression that evaluates to a single value.", "format_string: A string with the formatting template."), "A string containing value formatted as defined by format_string.", "Text functions", "Data Analysis Expressions (DAX) includes a set of text functions based on the library of string functions in Excel, but which have been modified to work with tables and columns in tabular models. This section describes text functions available in the DAX language."));


        this.daxFunctionsRepository.save(new DAXFunctions("CLOSINGBALANCEMONTH(<expression>,<dates>[,<filter>])", List.of("expression: An expression that returns a scalar value.", "dates: A column that contains dates.", "filter: (optional) An expression that specifies a filter to apply to the current context."), "A scalar value that represents the expression evaluated at the last date of the month in the current context.", "Time intelligence functions", "Data Analysis Expressions (DAX) includes time-intelligence functions that enable you to manipulate data using time periods, including days, months, quarters, and years, and then build and compare calculations over those periods."));


    }
}
